} else if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "G") {
count_G[i] = count_G[i] + 1
} else if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "C") {
count_C[i] = count_C[i] + 1
} else if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "T") {
count_T[i] = count_T[i] + 1
}
}
}
motif_count <- cbind(count_A, count_T, count_C, count_G) %>% data.frame()
motif_profile <- motif_count/length(motif_matrix)
motif_score <- motif_count %>% rowSums  - motif_count %>% do.call(pmax, .)
motif_consensus <- max.col(motif_count) %>% factor(., levels = c("1", "2" , "3",   "4"), labels = c("A", "T", "C", "G"))
# the entropy of a motif matrix is defined as the sum of the entropies of its columns
motif_profile %>% round(1) %>% mutate(
log2count_A = ifelse(count_A == 0,0,log2(count_A)),
log2count_T = ifelse(count_T == 0,0,log2(count_T)),
log2count_C = ifelse(count_C == 0,0,log2(count_C)),
log2count_G = ifelse(count_G == 0,0,log2(count_G)),
entropy = - (count_A*log2count_A + count_T*log2count_T + count_C*log2count_C + count_G*log2count_G)) %>% pull(entropy) %>% sum()
motif_profile
motif_count
motif_profile %>% round(1)
motif_profile %>% round(1) %>% mutate(
log2count_A = ifelse(count_A == 0,0,log2(count_A)),
log2count_T = ifelse(count_T == 0,0,log2(count_T)),
log2count_C = ifelse(count_C == 0,0,log2(count_C)),
log2count_G = ifelse(count_G == 0,0,log2(count_G)),
entropy = - (count_A*log2count_A + count_T*log2count_T + count_C*log2count_C + count_G*log2count_G)) %>% pull(entropy) %>% sum()
score <- -(8*0.1*log2(0.1) + 4*0.2*log2(0.2) + 2*0.3*log2(0.3) + 3*0.4*log2(0.4) + 1*0.5*log2(0.5) + 2*0.6*log2(0.6) + 2*0.7*log2(0.7) + 1*0.8*log2(0.8) + 3*0.9*log2(0.9))
score
motif_profile %>% round(1) %>% count(0.1)
1:length(motif_matrix)
length(motif_matrix)
1:length(motif_matrix)
motif_matrix
motif_matrix <- c(
"TCATATTTTT",
"CCCTATCCAC",
"GGGGGGGGGG",
"GGGGGGGGGG",
"GTGGGGGGGG",
"GGGGGGGGGT",
"GAAAAAAAAA",
"TCTCCCTTAT",
"TTTTTTTTCA",
"TTTTTTCCTA",
"TATTCCACAC",
"TCCTCCTTCC"
)
length(motif_matrix)
motif_matrix
library(data.table)
library(tidyverse)
motif_matrix <- c(
"TCGGGGGTTTTT",
"CCGGTGACTTAC",
"ACGGGGATTTTC",
"TTGGGGACTTTT",
"AAGGGGACTTCC",
"TTGGGGACTTCC",
"TCGGGGATTCAT",
"TCGGGGATTCCT",
"TAGGGGAACTAC",
"TCGGGTATAACC"
)
count_A <- rep(0, nchar(motif_matrix[1]))
count_T <- rep(0, nchar(motif_matrix[1]))
count_C <- rep(0, nchar(motif_matrix[1]))
count_G <- rep(0, nchar(motif_matrix[1]))
# j is the number of motifs in the matrix
# i is the length of each motif
for (i in 1:nchar(motif_matrix[1])) {
for (j in 1:length(motif_matrix)) {
if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "A") {
count_A[i] = count_A[i] + 1
} else if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "G") {
count_G[i] = count_G[i] + 1
} else if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "C") {
count_C[i] = count_C[i] + 1
} else if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "T") {
count_T[i] = count_T[i] + 1
}
}
}
motif_count <- cbind(count_A, count_T, count_C, count_G) %>% data.frame()
motif_profile <- motif_count/length(motif_matrix)
motif_score <- motif_count %>% rowSums  - motif_count %>% do.call(pmax, .)
motif_consensus <- max.col(motif_count) %>% factor(., levels = c("1", "2" , "3",   "4"), labels = c("A", "T", "C", "G"))
# the entropy of a motif matrix is defined as the sum of the entropies of its columns
motif_profile %>% round(1) %>% mutate(
log2count_A = ifelse(count_A == 0,0,log2(count_A)),
log2count_T = ifelse(count_T == 0,0,log2(count_T)),
log2count_C = ifelse(count_C == 0,0,log2(count_C)),
log2count_G = ifelse(count_G == 0,0,log2(count_G)),
entropy = - (count_A*log2count_A + count_T*log2count_T + count_C*log2count_C + count_G*log2count_G)) %>% pull(entropy) %>% sum()
motif_entropy <- sum()
score <- -(8*0.1*log2(0.1) + 4*0.2*log2(0.2) + 2*0.3*log2(0.3) + 3*0.4*log2(0.4) + 1*0.5*log2(0.5) + 2*0.6*log2(0.6) + 2*0.7*log2(0.7) + 1*0.8*log2(0.8) + 3*0.9*log2(0.9))
motif_profile %>% round(1) %>% count(0.1)
# the entropy of a motif matrix is defined as the sum of the entropies of its columns
motif_profile %>% round(1) %>% mutate(
log2count_A = ifelse(count_A == 0,0,log2(count_A)),
log2count_T = ifelse(count_T == 0,0,log2(count_T)),
log2count_C = ifelse(count_C == 0,0,log2(count_C)),
log2count_G = ifelse(count_G == 0,0,log2(count_G)),
entropy = - (count_A*log2count_A + count_T*log2count_T + count_C*log2count_C + count_G*log2count_G)) %>% pull(entropy) %>% sum()
# The first potential issue with implementing MedianString is writing a function to compute the sum of distances between Pattern and each string in Dna = {Dna1, ..., Dnat}. This task is achieved by the following pseudocode.
# DistanceBetweenPatternAndStrings(Pattern, Dna)
# k ← |Pattern|
#   distance ← 0
# for each string Text in Dna
# HammingDistance ← ∞
# for each k-mer Pattern’ in Text
# if HammingDistance > HammingDistance(Pattern, Pattern’)
# HammingDistance ← HammingDistance(Pattern, Pattern’)
# distance ← distance + HammingDistance
# return distance
# Sample Input:
#
#   AAA
# TTACCTTAAC GATATCTGTC ACGGCGTTCG CCCTAAAGAG CGTCAGAGGT
# Sample Output:
#
#   5
library(data.table)
library(tidyverse)
# HammingDistance function
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
pattern <- "AAA"
Dna  <- c("TTACCTTAAC", "GATATCTGTC", "ACGGCGTTCG", "CCCTAAAGAG", "CGTCAGAGGT")
DistanceBetweenPatternAndStrings_summary <- function(pattern, Dna) {
# create a list to hold the results
DistanceBetweenPatternAndStrings_summary_list <- list()
# string split the pattern input
pattern <- pattern %>% str_split(., "") %>% .[[1]]
for (S in 1:length(Dna)) {
mystr <- Dna[S] %>% str_split(., "") %>% .[[1]]
myk <- length(pattern)
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - as.numeric(myk) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
}
HammingDistance_summary <- vector()
for (i in 1:length(mylist)) {
HammingDistance_summary[i] <- HammingDistance(mylist[[i]], pattern)
}
HammingDistance_summary[which(HammingDistance_summary == min(HammingDistance_summary))]
# find the minimum value of the HammingDistance
min_value <- min(HammingDistance_summary)
# find the first index that gives the minmum HammingDistance
min_index <- which(HammingDistance_summary == min(HammingDistance_summary)) %>% min()
# find the k-mer that gave the minmum value
min_string <- mylist[[min_index]]
min_summary <- c(min_value = min_value, min_index = min_index, min_string = min_string)
DistanceBetweenPatternAndStrings_summary_list[[S]] <- min_summary
}
return(DistanceBetweenPatternAndStrings_summary_list)
}
# create the DistanceBetweenPatternAndStrings function
DistanceBetweenPatternAndStrings <- function(pattern, Dna) {
DistanceBetweenPatternAndStrings_summary_list <- DistanceBetweenPatternAndStrings_summary(pattern, Dna)
DistanceBetweenPatternAndStrings_summary_list %>%
map(~ .[[1]]) %>%
unlist() %>%
as.numeric() %>%
sum()
}
fread("dataset_5164_1.txt")
fread("dataset_5164_1.txt", fill = T)
fread("dataset_5164_1.txt", fill = T) %>% dim()
fread("dataset_5164_1.txt", fill = T) %>% names()
myDna <- fread("dataset_5164_1.txt", fill = T) %>% .[1,1]
myDna
myDna
myDna <- fread("dataset_5164_1.txt", fill = T) %>% separate(by = " ")
fread("dataset_5164_1.txt", fill = T) %>% .[1,1]
fread("dataset_5164_1.txt", fill = T) %>% .[1,1] %>% str_split(., " ")
mypattern <- fread("dataset_5164_1.txt", fill = T) %>% names()
length(myDna)
myDna
myDna <- fread("dataset_5164_1.txt", fill = T) %>% .[1,1] %>% str_split(., " ") %>% .[[1]]
myDna
length(myDna)
DistanceBetweenPatternAndStrings(mypattern, myDna)
library(data.table)
library(tidyverse)
# HammingDistance function
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
pattern <- "AAA"
Dna  <- c("TTACCTTAAC", "GATATCTGTC", "ACGGCGTTCG", "CCCTAAAGAG", "CGTCAGAGGT")
DistanceBetweenPatternAndStrings_summary <- function(pattern, Dna) {
# create a list to hold the results
DistanceBetweenPatternAndStrings_summary_list <- list()
# string split the pattern input
pattern <- pattern %>% str_split(., "") %>% .[[1]]
for (S in 1:length(Dna)) {
mystr <- Dna[S] %>% str_split(., "") %>% .[[1]]
myk <- length(pattern)
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - as.numeric(myk) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
}
HammingDistance_summary <- vector()
for (i in 1:length(mylist)) {
HammingDistance_summary[i] <- HammingDistance(mylist[[i]], pattern)
}
HammingDistance_summary[which(HammingDistance_summary == min(HammingDistance_summary))]
# find the minimum value of the HammingDistance
min_value <- min(HammingDistance_summary)
# find the first index that gives the minmum HammingDistance
min_index <- which(HammingDistance_summary == min(HammingDistance_summary)) %>% min()
# find the k-mer that gave the minmum value
min_string <- mylist[[min_index]]
min_summary <- c(min_value = min_value, min_index = min_index, min_string = min_string)
DistanceBetweenPatternAndStrings_summary_list[[S]] <- min_summary
}
return(DistanceBetweenPatternAndStrings_summary_list)
}
# create the DistanceBetweenPatternAndStrings function
DistanceBetweenPatternAndStrings <- function(pattern, Dna) {
DistanceBetweenPatternAndStrings_summary_list <- DistanceBetweenPatternAndStrings_summary(pattern, Dna)
DistanceBetweenPatternAndStrings_summary_list %>%
map(~ .[[1]]) %>%
unlist() %>%
as.numeric() %>%
sum()
}
?sample
c("A", "C", "G", "T") %>% sample(3, size = 4, replace = F)
c("A", "C", "G", "T") %>% sample(n = 3, size = 4, replace = F)
c("A", "C", "G", "T") %>% combn(mykmer)
mykmer <- 3
c("A", "C", "G", "T") %>% combn(mykmer)
c("A", "C", "G", "T") %>% combn(mykmer, simplify = F)
library(data.table)
library(tidyverse)
# HammingDistance function
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
DistanceBetweenPatternAndStrings_summary <- function(pattern, Dna) {
# create a list to hold the results
DistanceBetweenPatternAndStrings_summary_list <- list()
# string split the pattern input
# pattern <- pattern %>% str_split(., "") %>% .[[1]]
for (S in 1:length(Dna)) {
mystr <- Dna[S] %>% str_split(., "") %>% .[[1]]
myk <- nchar(pattern)
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - as.numeric(myk) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
}
HammingDistance_summary <- vector()
for (i in 1:length(mylist)) {
HammingDistance_summary[i] <- HammingDistance(mylist[[i]], pattern)
}
HammingDistance_summary[which(HammingDistance_summary == min(HammingDistance_summary))]
# find the minimum value of the HammingDistance
min_value <- min(HammingDistance_summary)
# find the first index that gives the minmum HammingDistance
min_index <- which(HammingDistance_summary == min(HammingDistance_summary)) %>% min()
# find the k-mer that gave the minmum value
min_string <- mylist[[min_index]]
min_summary <- c(min_value = min_value, min_index = min_index, min_string = min_string)
DistanceBetweenPatternAndStrings_summary_list[[S]] <- min_summary
}
return(DistanceBetweenPatternAndStrings_summary_list)
}
# create the DistanceBetweenPatternAndStrings function
DistanceBetweenPatternAndStrings <- function(pattern, Dna) {
DistanceBetweenPatternAndStrings_summary_list <- DistanceBetweenPatternAndStrings_summary(pattern, Dna)
DistanceBetweenPatternAndStrings_summary_list %>%
map(~ .[[1]]) %>%
unlist() %>%
as.numeric() %>%
sum()
}
# get the DistanceBetweenPatternAndStrings
kmer_list <- c("A", "C", "G", "T") %>% combn(mykmer, simplify = F)
kmer_list
DistanceBetweenPatternAndStrings(kmer_list[[1]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
kmer_list[[1]]
kmer_list <- c("A", "C", "G", "T") %>% combn(mykmer, simplify = F)
kmer_list
s <- c("A", "C", "G", "T") %>% combn(mykmer, simplify = F) %>% map(~ str_c(., collapse = ""))
c("A", "C", "G", "T") %>% combn(mykmer, simplify = F) %>% map(~ str_c(., collapse = ""))
mykmer_list <- c("A", "C", "G", "T") %>% combn(mykmer, simplify = F) %>% map(~ str_c(., collapse = ""))
# create the DistanceBetweenPatternAndStrings function
DistanceBetweenPatternAndStrings <- function(pattern, Dna) {
DistanceBetweenPatternAndStrings_summary_list <- DistanceBetweenPatternAndStrings_summary(pattern, Dna)
DistanceBetweenPatternAndStrings_summary_list %>%
map(~ .[[1]]) %>%
unlist() %>%
as.numeric() %>%
sum()
}
# generate all the k-mers
mykmer <- 3
mykmer_list <- c("A", "C", "G", "T") %>% combn(mykmer, simplify = F) %>% map(~ str_c(., collapse = ""))
DistanceBetweenPatternAndStrings(mykmer_list[[1]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
# create an empty list to store distance
distance_list <- list()
for (i in length(mykmer_list)) {
distance_list[[i]] <- DistanceBetweenPatternAndStrings(mykmer_list[[i]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
}
distance_list
istanceBetweenPatternAndStrings(mykmer_list[[i]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
DistanceBetweenPatternAndStrings(mykmer_list[[i]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
# generate all the k-mers
mykmer <- 3
mykmer_list <- c("A", "C", "G", "T") %>% combn(mykmer, simplify = F) %>% map(~ str_c(., collapse = ""))
mykmer_list
length(mykmer_list)
DistanceBetweenPatternAndStrings(mykmer_list[[1]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
DistanceBetweenPatternAndStrings(mykmer_list[[2]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
mykmer_list[[2]]
DistanceBetweenPatternAndStrings(mykmer_list[[3]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
DistanceBetweenPatternAndStrings(mykmer_list[[4]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
c("A", "C", "G", "T") %>% combn(mykmer, simplify = F) %>% map(~ str_c(., collapse = ""))
c("A", "C", "G", "T") %>% combn(mykmer, simplify = F)
?combn
DistanceBetweenPatternAndStrings("GGG", c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
DistanceBetweenPatternAndStrings("AAA", c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
# Input: An integer k, followed by a space-separated collection of strings Dna.
# Output: A k-mer Pattern that minimizes d(Pattern, Dna) among all possible choices of k-mers. (If there are multiple such strings Pattern, then you may return any one.)
# Sample Input:
#
#   3
# AAATTGACGCAT GACGACCACGTT CGTCAGCGCCTG GCTGAGCACCGG AGTTCGGGACAG
# Sample Output:
#
#   GAC
library(data.table)
library(tidyverse)
# HammingDistance function
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
DistanceBetweenPatternAndStrings_summary <- function(pattern, Dna) {
# create a list to hold the results
DistanceBetweenPatternAndStrings_summary_list <- list()
# string split the pattern input
pattern <- pattern %>% str_split(., "") %>% .[[1]]
for (S in 1:length(Dna)) {
mystr <- Dna[S] %>% str_split(., "") %>% .[[1]]
myk <- length(pattern)
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - as.numeric(myk) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
}
HammingDistance_summary <- vector()
for (i in 1:length(mylist)) {
HammingDistance_summary[i] <- HammingDistance(mylist[[i]], pattern)
}
HammingDistance_summary[which(HammingDistance_summary == min(HammingDistance_summary))]
# find the minimum value of the HammingDistance
min_value <- min(HammingDistance_summary)
# find the first index that gives the minmum HammingDistance
min_index <- which(HammingDistance_summary == min(HammingDistance_summary)) %>% min()
# find the k-mer that gave the minmum value
min_string <- mylist[[min_index]]
min_summary <- c(min_value = min_value, min_index = min_index, min_string = min_string)
DistanceBetweenPatternAndStrings_summary_list[[S]] <- min_summary
}
return(DistanceBetweenPatternAndStrings_summary_list)
}
# create the DistanceBetweenPatternAndStrings function
DistanceBetweenPatternAndStrings <- function(pattern, Dna) {
DistanceBetweenPatternAndStrings_summary_list <- DistanceBetweenPatternAndStrings_summary(pattern, Dna)
DistanceBetweenPatternAndStrings_summary_list %>%
map(~ .[[1]]) %>%
unlist() %>%
as.numeric() %>%
sum()
}
# get the DistanceBetweenPatternAndStrings
DistanceBetweenPatternAndStrings("AAA", c("TTACCTTAAC", "GATATCTGTC", "ACGGCGTTCG", "CCCTAAAGAG", "CGTCAGAGGT"))
DistanceBetweenPatternAndStrings("ACAA", c("TTACCTTAAC", "GATATCTGTC", "ACGGCGTTCG", "CCCTAAAGAG", "CGTCAGAGGT"))
DistanceBetweenPatternAndStrings("CAA", c("TTACCTTAAC", "GATATCTGTC", "ACGGCGTTCG", "CCCTAAAGAG", "CGTCAGAGGT"))
DistanceBetweenPatternAndStrings("AAA", c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
c("A", "C", "G", "T") %>% combn(3, simplify = F) %>% map(~ str_c(., collapse = ""))
bases <- c("A", "C", "G", "T")
bases
bases <- c("A", "C", "G", "T")
k <- 3
unique(t(combn(rep(bases, k), m = k)))
bases <- c("A", "C", "G", "T")
k <- 3
unique(t(combn(rep(bases, k), m = k))) %>% map(~ str_c(., collapse = ""))
bases <- c("A", "C", "G", "T")
k <- 3
unique(t(combn(rep(bases, k), m = k)))
unique(t(combn(rep(bases, k), m = k))) %>% data.frame()
unique(t(combn(rep(bases, k), m = k))) %>% data.frame() %>% paste0()
unique(t(combn(rep(bases, k), m = k)))
unique(t(combn(rep(bases, k), m = k))) %>% map(~ str_c(., collapse = " "))
unique(t(combn(rep(bases, k), m = k)))
combn
c("A", "C", "G", "T") %>% combn(3)
combn(rep(bases, k), m = k, simplify = F)
combn(rep(bases, k), m = k, simplify = F) %>% map(~ str_c(., collapse = " "))
combn(rep(bases, k), m = k, simplify = F) %>% map(~ str_c(., collapse = ""))
mykmer_list <- combn(rep(bases, k), m = k, simplify = F) %>% map(~ str_c(., collapse = ""))
DistanceBetweenPatternAndStrings(mykmer_list[[1]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
for (i in length(mykmer_list)) {
distance_list[[i]] <- DistanceBetweenPatternAndStrings(mykmer_list[[i]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
}
distance_list
# create an empty list to store distance
distance_list <- list()
for (i in length(mykmer_list)) {
distance_list[[i]] <- DistanceBetweenPatternAndStrings(mykmer_list[[i]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
}
distance_list
DistanceBetweenPatternAndStrings(mykmer_list[[1]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
length(mykmer_list)
DistanceBetweenPatternAndStrings(mykmer_list[[2]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
for (i in 1:length(mykmer_list)) {
distance_list[[i]] <- DistanceBetweenPatternAndStrings(mykmer_list[[i]], c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
}
distance_list
distance_list %>% min()
distance_list %>% unlist()
distance_vector <- distance_list %>% unlist()
distance_vector
# find the minimum value of the HammingDistance
min_value <- min(distance_vector)
min_value
# find the min index
min_index <- which(distance_vector == min(distance_vector)) %>% min()
min_index
# find the k-mer that gave the minmum value
min_kner <- distance_vector[[min_index]]
# find the k-mer that gave the minmum value
min_kmer <- distance_vector[[min_index]]
min_kmer
distance_vector[[min_index]]
distance_vector
# find the k-mer that gave the minmum value
min_kmer <- mykmer_list[[min_index]]
min_kmer
MedianString <- function(k, Dna) {
# generate all the k-mers
bases <- c("A", "C", "G", "T")
mykmer_list <- combn(rep(bases, k), m = k, simplify = F) %>% map(~ str_c(., collapse = ""))
# create an empty list to store distance
distance_list <- list()
for (i in 1:length(mykmer_list)) {
distance_list[[i]] <- DistanceBetweenPatternAndStrings(mykmer_list[[i]], Dna)
}
distance_vector <- distance_list %>% unlist()
# find the minimum value of the HammingDistance
min_value <- min(distance_vector)
# find the min index
min_index <- which(distance_vector == min(distance_vector)) %>% min()
# find the k-mer that gave the minmum value
min_kmer <- mykmer_list[[min_index]]
return(min_kmer)
}
MedianString(3, c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
fread("dataset_158_9.txt", fill = T)
fread("dataset_158_9.txt", fill = T) %>% [1,1]
fread("dataset_158_9.txt", fill = T) %>% .[1,1]
fread("dataset_158_9.txt", fill = T) %>% .[1,1] %>% pull()
myk <- fread("dataset_158_9.txt", fill = T) %>% .[1,1] %>% pull()
fread("dataset_158_9.txt", fill = T)%>% pull()
fread("dataset_158_9.txt", fill = T) %>% pull() %>% .[-1]
myDna <- fread("dataset_158_9.txt", fill = T) %>% pull() %>% .[-1]
MedianString(myk, myDna)
myk <- fread("dataset_158_9.txt", fill = T) %>% .[1,1] %>% pull() %>% as.numeric()
myk
myDna <- fread("dataset_158_9.txt", fill = T) %>% pull() %>% .[-1]
MedianString(myk, myDna)
myk
myDna
class(myDna)
length(myDna)
MedianString(3, myDna)
MedianString(3, c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
MedianString(6, myDna)
