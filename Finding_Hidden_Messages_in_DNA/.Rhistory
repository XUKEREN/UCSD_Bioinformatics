count <- function(pattern, string, d){
approx_pattern_matching(pattern, string, d) %>% length()
}
count(mypattern, mystring, d)
mypattern <- "TGT"
mystring <- "CGTGACAGTGTATGGGCATCTTT"
d <- 1
count(mypattern, mystring, d)
mypattern <- "TGT"
mystring <- "CGTGACAGTGTATGGGCATCTTT"
d <- 2
count(mypattern, mystring, d)
mypattern <- "TGT"
mypattern <- "TGT"
mystring <- "CGTGACAGTGTATGGGCATCTTT"
d <-  1
mypattern <- mypattern %>% str_split(., "") %>% .[[1]]
mystring <- mystring %>% str_split(., "") %>% .[[1]]
count(mypattern, mystring, d)
# Our goal is to generate the d-neighborhood Neighbors(Pattern, d), the set of all k-mers whose Hamming distance from Pattern does not exceed d. As a warm up, we will first generate the 1-neigborhood of Pattern using the following pseudocode.
#
# ImmediateNeighbors(Pattern)
# Neighborhood ← the set consisting of single string Pattern
# for i = 1 to |Pattern|
#   symbol ← i-th nucleotide of Pattern
# for each nucleotide x different from symbol
# Neighbor ← Pattern with the i-th nucleotide substituted by x
# add Neighbor to Neighborhood
# return Neighborhood
# load packages
library(data.table)
library(tidyverse)
# initiate a Neighborhood list
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(pattern)) {
symbol <- pattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
pattern_tmp <- pattern
pattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- pattern # assign the pattern to the output Neighborhood list
pattern <- pattern_tmp
}
}
Neighborhood <- c(Neighborhood, list(pattern))
return(Neighborhood)
}
# calculate all mismatch with hamming dist 1. then compute new mismatch with ham dist 1 from prev mismatch and recurse till d.
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
if (length(pattern) == 1) {
return(print("pattern has only one letter"))
Neighborhood <- list(NULL)
} else {
if (d == 0) {
Neighborhood = list(pattern)
} else if (d == 1) {
Neighborhood
} else if (d > 1) {
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique()
}
}
}
return(Neighborhood)
}
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
# create two blank lists
new_pattern_list1 <- list()
new_pattern_list2 <- list()
# crreate the function to check the suffix pattern and append the first letter
AppendFirstSymbol <- function(pattern, d) {
FirstSymbol <- pattern[1]
SuffixPattern <- pattern[-1]
SuffixPattern_Neighbors <- Neighbors(SuffixPattern, d)
for (i in 1:length(SuffixPattern_Neighbors)) {
pattern2 <- SuffixPattern_Neighbors[[i]]
if (HammingDistance(pattern2, SuffixPattern) < d) {
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=FirstSymbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
new_pattern_list1[[length(diff_nucleotide)*(i-1) + j]] <- c(diff_nucleotide[j], pattern2)
}
}
else if (HammingDistance(pattern2, SuffixPattern) == d) {
new_pattern_list2[[i]] <- c(FirstSymbol, pattern2)
}
}
new_pattern_list12 <- c(new_pattern_list1, new_pattern_list2, list(pattern))
new_pattern_list12 <- new_pattern_list12[!sapply(new_pattern_list12,is.null)] %>% unique()
return(new_pattern_list12)
}
# Code Challenge: Implement Neighbors to find the d-neighborhood of a string.
#
# Input: A string Pattern and an integer d.
# Output: The collection of strings Neighbors(Pattern, d). (You may return the strings in any order, but each line should contain only one string.)
# Sample Input:
#
#   ACG
# 1
# Sample Output:
#
#   CCG TCG GCG AAG ATG AGG ACA ACC ACT ACG
# apply to the sample input
mypattern <- "ACGT"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
AppendFirstSymbol(mypattern, 3)
AppendFirstSymbol(mypattern, 3) %>% unique()
# We say that position i in k-mers p1 … pk and q1 … qk is a mismatch if pi ≠ qi. For example, CGAAT and CGGAC have two mismatches. The number of mismatches between strings p and q is called the Hamming distance between these strings and is denoted HammingDistance(p, q).
#
# Hamming Distance Problem: Compute the Hamming distance between two strings.
#
# Input: Two strings of equal length.
# Output: The Hamming distance between these strings.
# Sample Input:
#
# GGGCCGTTGGT
# GGACCGTTGAC
# Sample Output:
#
# 3
library(data.table)
library(tidyverse)
HammingDistance <- function(string1, string2) {
# create two vectors from two strings
string1 <- string1 %>% str_split(., "") %>% .[[1]]
string2 <- string2 %>% str_split(., "") %>% .[[1]]
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
# apply this function on sample input
HammingDistance("GGGCCGTTGGT" , "GGACCGTTGAC")
# apply it to the dataset
# read dataset
mydata = fread('dataset_9_3.txt', stringsAsFactors = F, header = F)
HammingDistance(mydata[1,1] %>% pull() , mydata[2,1] %>% pull())
HammingDistance("CTACAGCAATACGATCATATGCGGATCCGCAGTGGCCGGTAGACACACGT", "CTACCCCGCTGCTCAATGACCGGGACTAAAGAGGCGAAGATTATGGTGTG")
# Let's follow the 5' → 3' direction of DNA and walk along the chromosome from ter to ori (along a reverse half-strand), then continue on from ori to ter (along a forward half-strand). In our previous discussion, we saw that the skew is decreasing along the reverse half-strand and increasing along the forward half-strand. Thus, the skew should achieve a minimum at the position where the reverse half-strand ends and the forward half-strand begins, which is exactly the location of ori!
#
# We have just developed an insight for a new algorithm for locating ori: it should be found where the skew attains a minimum.
#
# Minimum Skew Problem: Find a position in a genome where the skew diagram attains a minimum.
#
# Input: A DNA string Genome.
# Output: All integer(s) i minimizing Skewi (Genome) among all values of i (from 0 to |Genome|).
# load packages
library(data.table)
library(tidyverse)
# read dataset
mydata = fread('dataset_7_10.txt', stringsAsFactors = F, header = F)
skew_c_g <- function(input) {
# split the input string to a genome vector
genome <- input %>% str_split(., "") %>% .[[1]]
# create an empty output vector
output_vector <- vector()
# create the initial value of the output vector
output_vector[1] <- 0
for (i in 1:length(genome)) {
# check to see if the first element of the pattern matches any elements of the string
if (genome[i] %in% c("A", "T")) {
output_vector[i+1] <- output_vector[i]
} else if (genome[i] %in% c("C")) {
output_vector[i+1] <- output_vector[i] - 1
} else if (genome[i] %in% c("G")) {
output_vector[i+1] <- output_vector[i] + 1
}
}
return(output_vector)
}
# apply it to mydata
skew_c_g(mydata)
# return index of the smallest value in the vector
a <- skew_c_g(mydata)
which.min(a)
# results needs 1-based indexing
which(a == min(a))-1
mydata <- skew_c_g("GCATACACTTCCCAGTAGGTACTG")
# return index of the smallest value in the vector
which.min(mydata)
# results needs 1-based indexing
which(a == min(a))-1
mydata <- skew_c_g("CATTCCAGTACTTCGATGATGGCGTGAAGA")
# return index of the smallest value in the vector
which.min(mydata)
# results needs 1-based indexing
which(a == min(a))-1
mydata <- skew_c_g("CATTCCAGTACTTCGATGATGGCGTGAAGA")
# return index of the smallest value in the vector
which.min(mydata)
# results needs 1-based indexing
which(mydata == min(mydata))-1
# Our goal now is to modify our previous algorithm for the Frequent Words Problem in order to find DnaA boxes by identifying frequent k-mers, possibly with mismatches. Given strings Text and Pattern as well as an integer d, we define Countd(Text, Pattern) as the total number of occurrences of Pattern in Text with at most d mismatches. For example, Count1(AACAAGCTGATAAACATTTAAAGAG, AAAAA) = 4 because AAAAA appears four times in this string with at most one mismatch: AACAA, ATAAA, AAACA, and AAAGA. Note that two of these occurrences overlap.
#
# Exercise Break: Compute Count2(AACAAGCTGATAAACATTTAAAGAG, AAAAA).
# load packages
library(data.table)
library(tidyverse)
approx_pattern_matching <- function(pattern, string, d) {
# create an empty vector for the output
output_vector <- vector()
# HammingDistance function
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0)
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
# loop compare the pattern and a subset of the string
for (i in 1:(length(string) - length(pattern) + 1) ) {
if (HammingDistance(pattern, string[i: (i + length(pattern) - 1)]) <= d) {
output_vector[i] <- i
} else {
output_vector[i] <- NA
}
}
# return 0-based indexing
return(output_vector[which(!is.na(output_vector))] - 1)
}
# test the function on sample input
mypattern <- "AAAAA"
mystring <- "AACAAGCTGATAAACATTTAAAGAG"
d <- 1
# split strings to vectors
mypattern <- mypattern %>% str_split(., "") %>% .[[1]]
mystring <- mystring %>% str_split(., "") %>% .[[1]]
approx_pattern_matching(mypattern, mystring, d) %>% length()
# apply the function to the new strings
# read dataset
mypattern <- "AAAAA"
mystring <- "AACAAGCTGATAAACATTTAAAGAG"
d <- 2
# split strings to vectors
mypattern <- mypattern %>% str_split(., "") %>% .[[1]]
mystring <- mystring %>% str_split(., "") %>% .[[1]]
approx_pattern_matching(mypattern, mystring, d) %>% length()
# create a new count function
count <- function(pattern, string, d){
approx_pattern_matching(pattern, string, d) %>% length()
}
count(mypattern, mystring, d)
# try the sample input
mypattern <- "GAGG"
mystring <- "TTTAGAGCCTTCAGAGG"
d <- 2
mypattern <- mypattern %>% str_split(., "") %>% .[[1]]
mystring <- mystring %>% str_split(., "") %>% .[[1]]
count(mypattern, mystring, d)
# apply it to the dataset
# read dataset
mydata = fread('dataset_9_6.txt', stringsAsFactors = F, header = F)
# split strings to characters
mypattern <- mydata[1,1] %>% pull() %>% str_split(., "") %>% .[[1]]
mystring <- mydata[2,1] %>% pull() %>% str_split(., "") %>% .[[1]]
d <- mydata[3,1] %>% pull()
count(mypattern, mystring, d)
mypattern <- "CCC"
mystring <- "CATGCCATTCGCATTGTCCCAGTGA"
d <- 2
mypattern <- mypattern %>% str_split(., "") %>% .[[1]]
mystring <- mystring %>% str_split(., "") %>% .[[1]]
count(mypattern, mystring, d)
# Our goal is to generate the d-neighborhood Neighbors(Pattern, d), the set of all k-mers whose Hamming distance from Pattern does not exceed d. As a warm up, we will first generate the 1-neigborhood of Pattern using the following pseudocode.
#
# ImmediateNeighbors(Pattern)
# Neighborhood ← the set consisting of single string Pattern
# for i = 1 to |Pattern|
#   symbol ← i-th nucleotide of Pattern
# for each nucleotide x different from symbol
# Neighbor ← Pattern with the i-th nucleotide substituted by x
# add Neighbor to Neighborhood
# return Neighborhood
# load packages
library(data.table)
library(tidyverse)
# initiate a Neighborhood list
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(pattern)) {
symbol <- pattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
pattern_tmp <- pattern
pattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- pattern # assign the pattern to the output Neighborhood list
pattern <- pattern_tmp
}
}
Neighborhood <- c(Neighborhood, list(pattern))
return(Neighborhood)
}
# calculate all mismatch with hamming dist 1. then compute new mismatch with ham dist 1 from prev mismatch and recurse till d.
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
if (length(pattern) == 1) {
return(print("pattern has only one letter"))
Neighborhood <- list(NULL)
} else {
if (d == 0) {
Neighborhood = list(pattern)
} else if (d == 1) {
Neighborhood
} else if (d > 1) {
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique()
}
}
}
return(Neighborhood)
}
# In the following pseudocode, we use the notation symbol • Text to denote the concatenation of a character symbol and a string Text, e.g., A•GCATG = AGCATG.
#
#
# Neighbors(Pattern, d)
# if d = 0
# return {Pattern}
# if |Pattern| = 1
# return {A, C, G, T}
# Neighborhood ← an empty set
# SuffixNeighbors ← Neighbors(Suffix(Pattern), d)
# for each string Text from SuffixNeighbors
# if HammingDistance(Suffix(Pattern), Text) < d
# for each nucleotide x
# add x • Text to Neighborhood
# else
#   add FirstSymbol(Pattern) • Text to Neighborhood
# return Neighborhood
# create a function to append the first letter later
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
# create two blank lists
new_pattern_list1 <- list()
new_pattern_list2 <- list()
# crreate the function to check the suffix pattern and append the first letter
AppendFirstSymbol <- function(pattern, d) {
FirstSymbol <- pattern[1]
SuffixPattern <- pattern[-1]
SuffixPattern_Neighbors <- Neighbors(SuffixPattern, d)
for (i in 1:length(SuffixPattern_Neighbors)) {
pattern2 <- SuffixPattern_Neighbors[[i]]
if (HammingDistance(pattern2, SuffixPattern) < d) {
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=FirstSymbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
new_pattern_list1[[length(diff_nucleotide)*(i-1) + j]] <- c(diff_nucleotide[j], pattern2)
}
}
else if (HammingDistance(pattern2, SuffixPattern) == d) {
new_pattern_list2[[i]] <- c(FirstSymbol, pattern2)
}
}
new_pattern_list12 <- c(new_pattern_list1, new_pattern_list2, list(pattern))
new_pattern_list12 <- new_pattern_list12[!sapply(new_pattern_list12,is.null)] %>% unique()
return(new_pattern_list12)
}
# Code Challenge: Implement Neighbors to find the d-neighborhood of a string.
#
# Input: A string Pattern and an integer d.
# Output: The collection of strings Neighbors(Pattern, d). (You may return the strings in any order, but each line should contain only one string.)
# Sample Input:
#
#   ACG
# 1
# Sample Output:
#
#   CCG TCG GCG AAG ATG AGG ACA ACC ACT ACG
# apply to the sample input
mypattern <- "ACG"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
AppendFirstSymbol(mypattern, 1)
# apply to the dataset
mydata <- fread("dataset_3014_4.txt", stringsAsFactors = F, header = F)
# split strings to characters
mypattern <- mydata[1,1] %>% pull() %>% str_split(., "") %>% .[[1]]
d <- mydata[2,1] %>% pull()
vectorList <- AppendFirstSymbol(mypattern, d)
vectorList %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame() %>% fwrite("test.results.txt")
mypattern <- "CCAGTCAATG"
mypattern <- mydata[1,1] %>% pull() %>% str_split(., "") %>% .[[1]]
ImmediateNeighbors()
ImmediateNeighbors(mypattern)
mydata <- fread("/Users/kerenxu/UCSD_Bioinformatics/Finding_Hidden_Messages_in_DNA/FrequentWordsMismatches/inputs/input_5.txt", stringsAsFactors = F)
mydata <- fread("dataset_9_9.txt", stringsAsFactors = F)
mydata
mystring <- names(mydata)[2] %>% str_split(., "") %>% .[[1]]
k <- mydata[1,1] %>% pull()
d <- mydata[1,2] %>% pull()
mystring
mystring <- c("CCAGTCAATG") %>% str_split(., "") %>% .[[1]]
k <- 10
d <- 1
kmer_list <- vector(mode = "list", length = (length(mystring) - as.numeric(k) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystring) - as.numeric(k) + 1)) {
kmer_list[[i]] <- mystring[i:(i + as.numeric(k) - 1)]
}
# find all the mismatch patterns for the k-mers
###############################################
# initiate a Neighborhood list
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(pattern)) {
symbol <- pattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
pattern_tmp <- pattern
pattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- pattern # assign the pattern to the output Neighborhood list
pattern <- pattern_tmp
}
}
Neighborhood <- c(Neighborhood, list(pattern))
return(Neighborhood)
}
# calculate all mismatch with hamming dist 1. then compute new mismatch with ham dist 1 from prev mismatch and recurse till d.
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
if (length(pattern) == 1) {
Neighborhood # all the output should be in the list format
} else if (length(pattern) > 1) {
if (d == 0) {
Neighborhood = list(pattern) # all the output should be in the list format
} else if (d == 1) {
Neighborhood # all the output should be in the list format
} else if (d > 1) {
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique() # all the output should be in the list format
}
}
}
return(Neighborhood)
}
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
# create two blank lists
# new_pattern_list1 <- list()
# new_pattern_list2 <- list()
# new_pattern_list3 <- list()
# # create the function to check the suffix pattern and append the first letter
# AppendFirstSymbol <- function(pattern, d) {
#
#   FirstSymbol <- pattern[1]
#   SuffixPattern <- pattern[-1]
#
#   SuffixPattern_Neighbors <- Neighbors(SuffixPattern, d)
#
#   for (i in 1:length(SuffixPattern_Neighbors)) {
#
#     if (HammingDistance(SuffixPattern_Neighbors[[i]], SuffixPattern) < d) {
#
#       nucleotide <- c("A", "C", "G", "T")
#       diff_nucleotide <- nucleotide[which(nucleotide!=FirstSymbol)] # find all the different nucleotide
#       for (j in 1:length(diff_nucleotide)) {
#         new_pattern_list1[[length(diff_nucleotide)*(i-1) + j]] <- c(diff_nucleotide[j], SuffixPattern_Neighbors[[i]])
#
#       }
#     }
#     else if (HammingDistance(SuffixPattern_Neighbors[[i]], SuffixPattern) == d) {
#       new_pattern_list2[[i]] <- c(FirstSymbol, SuffixPattern_Neighbors[[i]])
#     }
#     else if (HammingDistance(SuffixPattern_Neighbors[[i]], SuffixPattern) > d) {
#       new_pattern_list3[[i]] <- NULL
#     }
#   }
#
#   new_pattern_list12 <- c(new_pattern_list1, new_pattern_list2, new_pattern_list3, list(pattern))
#
#   new_pattern_list12 <- new_pattern_list12[!sapply(new_pattern_list12,is.null)] %>% unique()
#
#   return(new_pattern_list12)
#
# }
#
kmer_Neighborhood <- list()
# for (i in 1:length(kmer_list)) {
#   kmer_Neighborhood[[i]] <- AppendFirstSymbol(kmer_list[[i]], d) %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
# }
for (i in 1:length(kmer_list)) {
kmer_Neighborhood[[i]] <- Neighbors(kmer_list[[i]], d) %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
}
kmer_Neighborhood
