count_G <- rep(0, nchar(motif[1]))
# j is the number of motifs in the matrix
# i is the length of each motif
for (i in 1:nchar(motif[1])) {
for (j in 1:length(motif)) {
if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "A") {
count_A[i] = count_A[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "G") {
count_G[i] = count_G[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "C") {
count_C[i] = count_C[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "T") {
count_T[i] = count_T[i] + 1
}
}
}
motif_count <- cbind(count_A, count_T, count_C, count_G) %>% data.frame()
motif_profile <- motif_count/length(motif)
motif_score <- motif_count %>% rowSums  - motif_count %>% do.call(pmax, .)
motif_score_sum <- sum(motif_score)
return(motif_score_sum)
}
# get the score from the profile comprising the first k-mer from each dna string
score_motif_int <- score_motif(best_motifs_int)
# profile motif
profile_motif <- function(motif) {
# initiate count vector for AGCT
count_A <- rep(0, nchar(motif[1]))
count_T <- rep(0, nchar(motif[1]))
count_C <- rep(0, nchar(motif[1]))
count_G <- rep(0, nchar(motif[1]))
# j is the number of motifs in the matrix
# i is the length of each motif
for (i in 1:nchar(motif[1])) {
for (j in 1:length(motif)) {
if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "A") {
count_A[i] = count_A[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "G") {
count_G[i] = count_G[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "C") {
count_C[i] = count_C[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "T") {
count_T[i] = count_T[i] + 1
}
}
}
motif_count <- cbind(count_A + 1, count_T + 1, count_C + 1, count_G + 1)
motif_profile <- motif_count/(length(motif) + 4)
return(motif_profile)
}
# create a function to find the profile for the first k-mer in the first string
# init a vector to hold all the profile_most_probable motif
# find all the k-mers for the first Dna string
first_DNA_string <- mystring[1] %>% str_split(., "") %>% .[[1]]
# create a place holder list
first_DNA_string_kmer <- vector(mode = "list", length = (length(first_DNA_string) - k + 1))
# put all the K-mer into mylist
for (i in 1:(length(first_DNA_string) - k + 1)) {
first_DNA_string_kmer[[i]] <- first_DNA_string[i:(i + k - 1)]
}
# get all the kmer from the first DNA string
first_DNA_string_kmer
# for each k-mer, extract the k-mers from all the rest DNA strings that are most_Probable
profile_extractor <- function(kmer) {
motif_vector <- vector()
motif_vector[1] <- kmer %>% paste(collapse = "")
for (a in 2:length(mystring)) {
# create profile for the current motif_vector
profile <- profile_motif(motif_vector) %>% t()
rownames(profile) <- c("A", "T", "C", "G")
# find out the profile_most_probable motif
# find out the profile_most_probable motif from the next Dna string
mystr <- mystring[a] %>% str_split(., "") %>% .[[1]]
# generate all the k-mer
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - k + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - k + 1)) {
mylist[[i]] <- mystr[i:(i + k - 1)]
}
Profile_most_Probable <- function(x) {
myprob <- prod(
profile["T",][which(x == "T")] %>% prod(),
profile["A",][which(x == "A")] %>% prod(),
profile["G",][which(x == "G")] %>% prod(),
profile["C",][which(x == "C")] %>% prod()
)
return(myprob)
}
myprob_vector <- mylist %>% map(Profile_most_Probable) %>% unlist()
motif_vector[a] <- mylist[which(myprob_vector == max(myprob_vector))] %>% .[[1]] %>% paste(collapse = "")
}
return(motif_vector)
}
# get all the motif profiles and calculate the score
final_motif_vector <- first_DNA_string_kmer %>% map(profile_extractor)
final_score_vector <- final_motif_vector %>% map(score_motif) %>% unlist()
# check the minimum score to see if its smaller than score_motif_int
score_motif_int
final_score_vector[which(final_score_vector == min(final_score_vector)) %>% min() ]
if (score_motif_int <= final_score_vector[which(final_score_vector == min(final_score_vector)) %>% min() ] ) {
print(best_motifs_int %>% noquote())
} else {
print(final_motif_vector[[which(final_score_vector == min(final_score_vector)) %>% min() ]] %>% noquote())
}
library(data.table)
library(tidyverse)
# import the dataset
mystring <- fread("dataset_160_9.txt", fill = T) %>% .[2] %>% as.vector() %>% as.character()
k <- fread("dataset_160_9.txt", fill = T) %>% .[1,1] %>% as.numeric() # k-mer
t <- fread("dataset_160_9.txt", fill = T) %>% .[1,2] %>% as.numeric() # number of k-mer (number of the DNA string) for the profile
mystring
k
t
library(data.table)
library(tidyverse)
# import the dataset
mystring <- fread("dataset_160_9.txt", fill = T) %>% .[2] %>% as.vector() %>% as.character()
k <- fread("dataset_160_9.txt", fill = T) %>% .[1,1] %>% as.numeric() # k-mer
t <- fread("dataset_160_9.txt", fill = T) %>% .[1,2] %>% as.numeric() # number of k-mer (number of the DNA string) for the profile
# first find out the first k-mer for each DNA string in mystring
BestMotifs_function <- function(string, k) {
string %>% str_split(., "") %>% .[[1]] %>% .[1:k] %>% paste(collapse = "")
}
# apply the function to mystring to extract the first k-mer from each dna string.
best_motifs_int <- mystring %>% map(BestMotifs_function, k) %>% unlist()
# This list will be used to compare against other motif lists that we will build later in the algorithm.
# score motif
score_motif <- function(motif) {
# initiate count vector for AGCT
count_A <- rep(0, nchar(motif[1]))
count_T <- rep(0, nchar(motif[1]))
count_C <- rep(0, nchar(motif[1]))
count_G <- rep(0, nchar(motif[1]))
# j is the number of motifs in the matrix
# i is the length of each motif
for (i in 1:nchar(motif[1])) {
for (j in 1:length(motif)) {
if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "A") {
count_A[i] = count_A[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "G") {
count_G[i] = count_G[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "C") {
count_C[i] = count_C[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "T") {
count_T[i] = count_T[i] + 1
}
}
}
motif_count <- cbind(count_A, count_T, count_C, count_G) %>% data.frame()
motif_profile <- motif_count/length(motif)
motif_score <- motif_count %>% rowSums  - motif_count %>% do.call(pmax, .)
motif_score_sum <- sum(motif_score)
return(motif_score_sum)
}
# get the score from the profile comprising the first k-mer from each dna string
score_motif_int <- score_motif(best_motifs_int)
# profile motif
profile_motif <- function(motif) {
# initiate count vector for AGCT
count_A <- rep(0, nchar(motif[1]))
count_T <- rep(0, nchar(motif[1]))
count_C <- rep(0, nchar(motif[1]))
count_G <- rep(0, nchar(motif[1]))
# j is the number of motifs in the matrix
# i is the length of each motif
for (i in 1:nchar(motif[1])) {
for (j in 1:length(motif)) {
if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "A") {
count_A[i] = count_A[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "G") {
count_G[i] = count_G[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "C") {
count_C[i] = count_C[i] + 1
} else if (motif[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "T") {
count_T[i] = count_T[i] + 1
}
}
}
motif_count <- cbind(count_A + 1, count_T + 1, count_C + 1, count_G + 1)
motif_profile <- motif_count/(length(motif) + 4)
return(motif_profile)
}
# create a function to find the profile for the first k-mer in the first string
# init a vector to hold all the profile_most_probable motif
# find all the k-mers for the first Dna string
first_DNA_string <- mystring[1] %>% str_split(., "") %>% .[[1]]
# create a place holder list
first_DNA_string_kmer <- vector(mode = "list", length = (length(first_DNA_string) - k + 1))
# put all the K-mer into mylist
for (i in 1:(length(first_DNA_string) - k + 1)) {
first_DNA_string_kmer[[i]] <- first_DNA_string[i:(i + k - 1)]
}
# get all the kmer from the first DNA string
first_DNA_string_kmer
# for each k-mer, extract the k-mers from all the rest DNA strings that are most_Probable
profile_extractor <- function(kmer) {
motif_vector <- vector()
motif_vector[1] <- kmer %>% paste(collapse = "")
for (a in 2:length(mystring)) {
# create profile for the current motif_vector
profile <- profile_motif(motif_vector) %>% t()
rownames(profile) <- c("A", "T", "C", "G")
# find out the profile_most_probable motif
# find out the profile_most_probable motif from the next Dna string
mystr <- mystring[a] %>% str_split(., "") %>% .[[1]]
# generate all the k-mer
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - k + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - k + 1)) {
mylist[[i]] <- mystr[i:(i + k - 1)]
}
Profile_most_Probable <- function(x) {
myprob <- prod(
profile["T",][which(x == "T")] %>% prod(),
profile["A",][which(x == "A")] %>% prod(),
profile["G",][which(x == "G")] %>% prod(),
profile["C",][which(x == "C")] %>% prod()
)
return(myprob)
}
myprob_vector <- mylist %>% map(Profile_most_Probable) %>% unlist()
motif_vector[a] <- mylist[which(myprob_vector == max(myprob_vector))] %>% .[[1]] %>% paste(collapse = "")
}
return(motif_vector)
}
# get all the motif profiles and calculate the score
final_motif_vector <- first_DNA_string_kmer %>% map(profile_extractor)
final_score_vector <- final_motif_vector %>% map(score_motif) %>% unlist()
# check the minimum score to see if its smaller than score_motif_int
score_motif_int
final_score_vector[which(final_score_vector == min(final_score_vector)) %>% min() ]
if (score_motif_int <= final_score_vector[which(final_score_vector == min(final_score_vector)) %>% min() ] ) {
print(best_motifs_int %>% noquote())
} else {
print(final_motif_vector[[which(final_score_vector == min(final_score_vector)) %>% min() ]] %>% noquote())
}
library(data.table)
library(tidyverse)
motif_profile
entropy = - (0.25*log2(0.25)+ 0.25*log2(0.25) + 0.25*log2(0.25) + 0.25*log2(0.25))) %>% sum()
entropy = - (0.25*log2(0.25)+ 0.25*log2(0.25) + 0.25*log2(0.25) + 0.25*log2(0.25)) %>% sum()
entropy
entropy = - (0.5*log2(0.5)+0.5*log2(0.5)) %>% sum()
entropy
entropy = - (0.25*log2(0.25)+ 0.25*log2(0.25) + 0.5*log2(0.5) ) %>% sum()
entropy
entropy = - (log2(1)) %>% sum()
entropy
library(data.table)
library(tidyverse)
# load a motif
motif_matrix <- c(
"TCGGGGGTTTTT",
"CCGGTGACTTAC",
"ACGGGGATTTTC",
"TTGGGGACTTTT",
"AAGGGGACTTCC",
"TTGGGGACTTCC",
"TCGGGGATTCAT",
"TCGGGGATTCCT",
"TAGGGGAACTAC",
"TCGGGTATAACC"
)
# initiate count vector for AGCT
count_A <- rep(0, nchar(motif_matrix[1]))
count_T <- rep(0, nchar(motif_matrix[1]))
count_C <- rep(0, nchar(motif_matrix[1]))
count_G <- rep(0, nchar(motif_matrix[1]))
# j is the number of motifs in the matrix
# i is the length of each motif
for (i in 1:nchar(motif_matrix[1])) {
for (j in 1:length(motif_matrix)) {
if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "A") {
count_A[i] = count_A[i] + 1
} else if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "G") {
count_G[i] = count_G[i] + 1
} else if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "C") {
count_C[i] = count_C[i] + 1
} else if (motif_matrix[j] %>% str_split(., "") %>% .[[1]] %>% .[[i]] == "T") {
count_T[i] = count_T[i] + 1
}
}
}
motif_count <- cbind(count_A, count_T, count_C, count_G) %>% data.frame()
motif_profile <- motif_count/length(motif_matrix)
motif_profile
count_A <- c("0.4", "0.3", "0.0", "0.1" , "0.0", "0.9")
count_C <- c( "0.2" , "0.3", "0.0", "0.4", "0.0", "0.1")
count_G <- c("0.1", "0.3", "1.0", "0.1", "0.5", "0.0")
count_T <- c("0.3", "0.1", "0.0", "0.4", "0.5", "0.0")
motif_count <- cbind(count_A, count_T, count_C, count_G) %>% data.frame()
motif_profile <- motif_count/length(motif_matrix)
motif_score <- motif_count %>% rowSums  - motif_count %>% do.call(pmax, .)
motif_consensus <- max.col(motif_count) %>% factor(., levels = c("1", "2" , "3",   "4"), labels = c("A", "T", "C", "G"))
motif_profile
count_A <- c("0.4", "0.3", "0.0", "0.1" , "0.0", "0.9")
count_C <- c( "0.2" , "0.3", "0.0", "0.4", "0.0", "0.1")
count_G <- c("0.1", "0.3", "1.0", "0.1", "0.5", "0.0")
count_T <- c("0.3", "0.1", "0.0", "0.4", "0.5", "0.0")
motif_score <- motif_count %>% rowSums  - motif_count %>% do.call(pmax, .)
motif_profile <- cbind(count_A, count_T, count_C, count_G)
motif_profile
count_T <- c("0.3", "0.1", "0.0", "0.4", "0.5", "0.0") %>% as.numeric()
count_A <- c("0.4", "0.3", "0.0", "0.1" , "0.0", "0.9")  %>% as.numeric()
count_C <- c( "0.2" , "0.3", "0.0", "0.4", "0.0", "0.1") %>% as.numeric()
count_G <- c("0.1", "0.3", "1.0", "0.1", "0.5", "0.0") %>% as.numeric()
count_T <- c("0.3", "0.1", "0.0", "0.4", "0.5", "0.0") %>% as.numeric()
motif_profile <- cbind(count_A, count_T, count_C, count_G)
motif_score <- motif_count %>% rowSums  - motif_count %>% do.call(pmax, .)
motif_profile
motif_consensus <- max.col(motif_count) %>% factor(., levels = c("1", "2" , "3",   "4"), labels = c("A", "T", "C", "G"))
motif_consensus
# Input: An integer k, followed by a space-separated collection of strings Dna.
# Output: A k-mer Pattern that minimizes d(Pattern, Dna) among all possible choices of k-mers. (If there are multiple such strings Pattern, then you may return any one.)
# Sample Input:
#
#   3
# AAATTGACGCAT GACGACCACGTT CGTCAGCGCCTG GCTGAGCACCGG AGTTCGGGACAG
# Sample Output:
#
#   GAC
library(data.table)
library(tidyverse)
# HammingDistance function
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
DistanceBetweenPatternAndStrings_summary <- function(pattern, Dna) {
# create a list to hold the results
DistanceBetweenPatternAndStrings_summary_list <- list()
# string split the pattern input
pattern <- pattern %>% str_split(., "") %>% .[[1]]
for (S in 1:length(Dna)) {
mystr <- Dna[S] %>% str_split(., "") %>% .[[1]]
myk <- length(pattern)
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - as.numeric(myk) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
}
HammingDistance_summary <- vector()
for (i in 1:length(mylist)) {
HammingDistance_summary[i] <- HammingDistance(mylist[[i]], pattern)
}
HammingDistance_summary[which(HammingDistance_summary == min(HammingDistance_summary))]
# find the minimum value of the HammingDistance
min_value <- min(HammingDistance_summary)
# find the first index that gives the minmum HammingDistance
min_index <- which(HammingDistance_summary == min(HammingDistance_summary)) %>% min()
# find the k-mer that gave the minmum value
min_string <- mylist[[min_index]]
min_summary <- c(min_value = min_value, min_index = min_index, min_string = min_string)
DistanceBetweenPatternAndStrings_summary_list[[S]] <- min_summary
}
return(DistanceBetweenPatternAndStrings_summary_list)
}
# create the DistanceBetweenPatternAndStrings function
DistanceBetweenPatternAndStrings <- function(pattern, Dna) {
DistanceBetweenPatternAndStrings_summary_list <- DistanceBetweenPatternAndStrings_summary(pattern, Dna)
DistanceBetweenPatternAndStrings_summary_list %>%
map(~ .[[1]]) %>%
unlist() %>%
as.numeric() %>%
sum()
}
# get the DistanceBetweenPatternAndStrings test sample
DistanceBetweenPatternAndStrings("AAA", c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
bases <- c("A", "C", "G", "T")
k = 3
mykmer_list <- combn(rep(bases, k), m = k, simplify = F)
distance_list <- mykmer_list %>% map(~ str_c(., collapse = "")) %>% map(DistanceBetweenPatternAndStrings, c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
distance_vector <- distance_list %>% unlist()
# find the minimum value of the HammingDistance
min_value <- min(distance_vector)
# find the min index
min_index <- which(distance_vector == min(distance_vector)) %>% min()
# find the k-mer that gave the minmum value
min_kmer <- mykmer_list[[min_index]]
MedianString <- function(k, Dna) {
# generate all the k-mers
bases <- c("A", "C", "G", "T")
mykmer_list <- combn(rep(bases, k), m = k, simplify = F)
distance_list <- mykmer_list %>% map(~ str_c(., collapse = "")) %>% map(DistanceBetweenPatternAndStrings, Dna)
distance_vector <- distance_list %>% unlist()
# find the minimum value of the HammingDistance
min_value <- min(distance_vector)
# find the min index
min_index <- which(distance_vector == min(distance_vector)) %>% min()
# find the k-mer that gave the minmum value
min_kmer <- mykmer_list[[min_index]]
return(min_kmer)
}
MedianString(3, c("AAATTGACGCAT", "GACGACCACGTT", "CGTCAGCGCCTG", "GCTGAGCACCGG", "AGTTCGGGACAG"))
MedianString(7, c("CTCGATGAGTAGGAAAGTAGTTTCACTGGGCGAACCACCCCGGCGCTAATCCTAGTGCCC", "GCAATCCTACCCGAGGCCACATATCAGTAGGAACTAGAACCACCACGGGTGGCTAGTTTC", "GGTGTTGAACCACGGGGTTAGTTTCATCTATTGTAGGAATCGGCTTCAAATCCTACACAG"))
# modify the MedianString function to grab all kmers of all the sequences instead of listing all the potential k-mers to save time
MedianString <- function(k, Dna) {
# a function to grab all kmers of all the sequences
grab_kmer <- function(x, k) {
mystr <- x %>% str_split(., "") %>% .[[1]]
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - k + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - k + 1)) {
mylist[[i]] <- mystr[i:(i + k - 1)]
}
return(mylist)
}
# apply the function to the input dna to get k-mer list
mykmer_list <- Dna %>% map(grab_kmer, k) %>% flatten()
# calculate the distance of each k-mer with the strings
distance_list <- mykmer_list %>% map(~ str_c(., collapse = "")) %>% map(DistanceBetweenPatternAndStrings, Dna)
distance_vector <- distance_list %>% unlist()
# find the minimum value of the HammingDistance
min_value <- min(distance_vector)
# find the min index
min_index <- which(distance_vector == min(distance_vector)) %>% min()
# find the k-mer that gave the minmum value
min_kmer <- mykmer_list[[min_index]]
return(min_kmer)
}
MedianString(7, c("CTCGATGAGTAGGAAAGTAGTTTCACTGGGCGAACCACCCCGGCGCTAATCCTAGTGCCC", "GCAATCCTACCCGAGGCCACATATCAGTAGGAACTAGAACCACCACGGGTGGCTAGTTTC", "GGTGTTGAACCACGGGGTTAGTTTCATCTATTGTAGGAATCGGCTTCAAATCCTACACAG"))
# modify the MedianString function to grab all kmers of all the sequences instead of listing all the potential k-mers to save time
MedianString <- function(k, Dna) {
# a function to grab all kmers of all the sequences
grab_kmer <- function(x, k) {
mystr <- x %>% str_split(., "") %>% .[[1]]
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - k + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - k + 1)) {
mylist[[i]] <- mystr[i:(i + k - 1)]
}
return(mylist)
}
# apply the function to the input dna to get k-mer list
mykmer_list <- Dna %>% map(grab_kmer, k) %>% flatten()
# calculate the distance of each k-mer with the strings
distance_list <- mykmer_list %>% map(~ str_c(., collapse = "")) %>% map(DistanceBetweenPatternAndStrings, Dna)
distance_vector <- distance_list %>% unlist()
# find the minimum value of the HammingDistance
min_value <- min(distance_vector)
# find the min index
min_index <- which(distance_vector == min(distance_vector))
# find the k-mer that gave the minmum value
min_kmer <- mykmer_list[[min_index]]
return(min_kmer)
}
MedianString(7, c("CTCGATGAGTAGGAAAGTAGTTTCACTGGGCGAACCACCCCGGCGCTAATCCTAGTGCCC", "GCAATCCTACCCGAGGCCACATATCAGTAGGAACTAGAACCACCACGGGTGGCTAGTTTC", "GGTGTTGAACCACGGGGTTAGTTTCATCTATTGTAGGAATCGGCTTCAAATCCTACACAG"))
k <- 7
Dna <- c("CTCGATGAGTAGGAAAGTAGTTTCACTGGGCGAACCACCCCGGCGCTAATCCTAGTGCCC", "GCAATCCTACCCGAGGCCACATATCAGTAGGAACTAGAACCACCACGGGTGGCTAGTTTC", "GGTGTTGAACCACGGGGTTAGTTTCATCTATTGTAGGAATCGGCTTCAAATCCTACACAG")
grab_kmer <- function(x, k) {
mystr <- x %>% str_split(., "") %>% .[[1]]
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - k + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - k + 1)) {
mylist[[i]] <- mystr[i:(i + k - 1)]
}
return(mylist)
}
# apply the function to the input dna to get k-mer list
mykmer_list <- Dna %>% map(grab_kmer, k) %>% flatten()
# calculate the distance of each k-mer with the strings
distance_list <- mykmer_list %>% map(~ str_c(., collapse = "")) %>% map(DistanceBetweenPatternAndStrings, Dna)
distance_vector <- distance_list %>% unlist()
# find the minimum value of the HammingDistance
min_value <- min(distance_vector)
which(distance_vector == min(distance_vector))
mykmer_list[[9]]
mykmer_list[[18]]
mykmer_list[[32]]
mykmer_list[[48]]
mykmer_list[[57]]
mykmer_list[[81]]
mykmer_list[[91]]
mykmer_list[[108]]
mykmer_list[[115]]
mykmer_list[[127]]
mykmer_list[[141]]
mykmer_list[[157]]
profile <- rbind(
A <- c(0.4,  0.3,  0.0,  0.1,  0.0,  0.9),
C <- c(0.2 , 0.3,  0.0,  0.4 , 0.0 , 0.1),
G <- c(0.1  ,0.3,  1.0 , 0.1,  0.5  ,0.0),
T <- c(0.3  ,0.1,  0.0,  0.4 , 0.5  ,0.0)
)
Profile_most_Probable <- function(x) {
myprob <- prod(
profile["T",][which(x == "T")] %>% prod(),
profile["A",][which(x == "A")] %>% prod(),
profile["G",][which(x == "G")] %>% prod(),
profile["C",][which(x == "C")] %>% prod()
)
return(myprob)
}
Profile_most_Probable(TCGGTA)
Profile_most_Probable("TCGGTA")
Profile_most_Probable("TCGGTA" %>% str_split(., "") %>% .[[1]])
Profile_most_Probable(c("TCGGTA") %>% str_split(., "") %>% .[[1]])
c("TCGGTA") %>% str_split(., "")
c("TCGGTA") %>% str_split(., "") %>% .[[1]]
Profile_most_Probable(c("TCGGTA") %>% str_split(., "") %>% .[[1]])
rownames(profile) <- c("A", "C", "G", "T")
Profile_most_Probable(c("TCGGTA") %>% str_split(., "") %>% .[[1]])
