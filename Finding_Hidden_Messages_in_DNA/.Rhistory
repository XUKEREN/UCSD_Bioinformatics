if (mystr[i] == mypattern[1]) {
# if these is match for the first element, then check the following elements
nequal = 1
for (j in 1:(length(mypattern) - 1)) {
if (mystr[i+j] == mypattern[1+j] && !is.na(mystr[i+j])) {nequal = nequal + 1}
else {
break;
}}
if (nequal == length(mypattern)) {
npattern = npattern + 1;
} else {
next;
}
} else {
next;
}
}
print(npattern)
# read dataset
mydata = fread('dataset_2_6.txt', stringsAsFactors = F, header = F)
mypattern
mydata[2,1]
# split strings to characters
mypattern <- c("GACCATCAAAACTGATAAACTACTTAAAAATCAGT") %>% str_split(., "") %>% .[[1]]
mypattern
# load packages
library(data.table)
library(tidyverse)
# read dataset
# split strings to characters
mypattern <- c("GACCATCAAAACTGATAAACTACTTAAAAATCAGT") %>% str_split(., "") %>% .[[1]]
mystr <- c("AAA") %>% str_split(., "") %>% .[[1]]
# initalize the number of matched pattern = 0
npattern=0
# for loop to count the matched patterns
for (i in 1:length(mystr)) {
# check to see if the first element of the pattern matches any elements of the string
if (mystr[i] == mypattern[1]) {
# if these is match for the first element, then check the following elements
nequal = 1
for (j in 1:(length(mypattern) - 1)) {
if (mystr[i+j] == mypattern[1+j] && !is.na(mystr[i+j])) {nequal = nequal + 1}
else {
break;
}}
if (nequal == length(mypattern)) {
npattern = npattern + 1;
} else {
next;
}
} else {
next;
}
}
print(npattern)
c("AAA") %>% str_split(., "") %>% .[[1]]
c("GACCATCAAAACTGATAAACTACTTAAAAATCAGT") %>% str_split(., "") %>% .[[1]]
# split strings to characters
mypattern <- c("GACCATCAAAACTGATAAACTACTTAAAAATCAGT") %>% str_split(., "") %>% .[[1]]
mystr <- c("AAA") %>% str_split(., "") %>% .[[1]]
# initalize the number of matched pattern = 0
npattern=0
# for loop to count the matched patterns
for (i in 1:length(mystr)) {
# check to see if the first element of the pattern matches any elements of the string
if (mystr[i] == mypattern[1]) {
# if these is match for the first element, then check the following elements
nequal = 1
for (j in 1:(length(mypattern) - 1)) {
if (mystr[i+j] == mypattern[1+j] && !is.na(mystr[i+j])) {nequal = nequal + 1}
else {
break;
}}
if (nequal == length(mypattern)) {
npattern = npattern + 1;
} else {
next;
}
} else {
next;
}
}
print(npattern)
# read dataset
mydata = fread('dataset_2_13.txt', stringsAsFactors = F, header = F)
# split strings to characters
mystr <- mydata[1,1] %>% pull() %>% str_split(., "") %>% .[[1]]
myk <- mydata[2,1] %>% pull()
myk
myk <- 3
myk
myk <- "3"
myk
# split strings to characters
mystr <- c("TAAACGTGAGAGAAACGTGCTGATTACACTTGTTCGTGTGGTAT") %>% str_split(., "") %>% .[[1]]
# split strings to characters
mystr <- c("TAAACGTGAGAGAAACGTGCTGATTACACTTGTTCGTGTGGTAT") %>% str_split(., "") %>% .[[1]]
myk <- "3"
# create a place holder list
mylist <- vector(mode = "list", length = (length(mystr) - as.numeric(myk) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
}
# calculate freq for each k-mer and print out the most frequent k-mer
mylist %>%
map(~ str_c(., collapse = "")) %>%
unlist() %>%
table() %>%
data.frame() %>%
filter(Freq == max(Freq)) %>%
pull(1)
# load packages
library(data.table)
library(tidyverse)
# read dataset
# split strings to letters
mystr <- c("GATTACA") %>% str_split(., "") %>% .[[1]]
# create a place holder list
mylist <- vector(mode = "list", length = length(mystr))
# add complement
for (i in 1:length(mystr)) {
if (mystr[i] == "A") {
mylist[[i]] <- "T"
} else if (mystr[i] == "T") {
mylist[[i]] <- "A"
} else if (mystr[i] == "G") {
mylist[[i]] <- "C"
} else if (mystr[i] == "C") {
mylist[[i]] <- "G"
} else {
mylist[[i]] <- "N"
}
}
# collapse all the letters and get the reversed vector
mylist %>% unlist() %>% rev() %>% str_c(collapse = "")
# Code Challenge: Solve the Pattern Matching Problem.
# Input: Two strings, Pattern and Genome.
# Output: A collection of space-separated integers specifying all starting positions where Pattern appears as a substring of Genome.
# load packages
library(data.table)
library(tidyverse)
# split strings to characters
mypattern <- c("CGC") %>% str_split(., "") %>% .[[1]]
mygenome <- c("ATGACTTCGCTGTTACGCGC") %>% str_split(., "") %>% .[[1]]
# create a place holder list
mylist <- vector(mode = "list", length = (length(mygenome) - length(mypattern) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mygenome) - length(mypattern) + 1)) {
mylist[[i]] <- mygenome[i:(i + length(mypattern) - 1)]
}
# find the matched k-mers and their index, index should minus 1
mylist %>%
map(~ str_c(., collapse = "")) %>%
unlist() %>%
data.frame() %>%
rownames_to_column() %>%
filter(`.` ==  str_c(mypattern, collapse = "")) %>%
mutate(index = as.numeric(rowname) - 1) %>%
pull(index) %>% str_c(., collapse = " ")
mypattern <- "ACGTTGCATGTCGCATGATGCATGAGAGCT"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
# initiate a Neighborhood list
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(mypattern)) {
symbol <- mypattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
mypattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- mypattern # assign the pattern to the output Neighborhood list
}
}
return(Neighborhood)
}
Neighborhood <- ImmediateNeighbors(mypattern)
Neighborhood
mypattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(mypattern)) {
symbol <- mypattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
mypattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- mypattern # assign the pattern to the output Neighborhood list
}
}
return(Neighborhood)
}
ImmediateNeighbors(mypattern)
mypattern <- "ACGTTGCATGTCGCATGATGCATGAGAGCT"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
# load packages
library(data.table)
library(tidyverse)
mypattern <- "ACGTTGCATGTCGCATGATGCATGAGAGCT"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
# initiate a Neighborhood list
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(mypattern)) {
symbol <- mypattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
mypattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- mypattern # assign the pattern to the output Neighborhood list
}
}
return(Neighborhood)
}
Neighbors <- function(d) {
Neighborhood <- ImmediateNeighbors(mypattern)
for (i in 1:d) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten()
}
}
Neighbors(2)
Neighborhood
Neighborhood <- ImmediateNeighbors(mypattern)
Neighborhood
Neighborhood %>% map(ImmediateNeighbors) %>% flatten()
Neighbors <- function(d) {
Neighborhood <- ImmediateNeighbors(mypattern)
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten()
}
return(Neighborhood)
}
Neighbors(2)
Neighbors(3)
Neighbors(4)
Neighbors(mypattern, 1)
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten()
}
return(Neighborhood)
}
Neighbors(mypattern, 1)
mypattern
mypattern <- "ACG"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
Neighbors(mypattern, 1)
# load packages
library(data.table)
library(tidyverse)
mypattern <- "ACG"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
Neighbors(mypattern, 1)
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(mypattern)) {
symbol <- mypattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
mypattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- mypattern # assign the pattern to the output Neighborhood list
}
}
return(Neighborhood)
}
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten()
}
return(Neighborhood)
}
Neighborhood <- list()
mypattern <- "ACG"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
Neighbors(mypattern, 1)
Neighbors(mypattern, 1) %>% flattern()
Neighbors(mypattern, 1) %>% flatten()
Neighbors(mypattern, 1)
Neighbors(mypattern, 1)
Neighbors(mypattern, 1) %>% rbindlist()
Neighbors(mypattern, 1) %>% rbindlist()
Neighbors(mypattern, 1) %>% rbindList()
Neighbors(mypattern, 1) %>% rbind()
Neighbors(mypattern, 1) %>% rbind() %>% dim()
Neighbors(mypattern, 1) %>% cbind() %>% dim()
Neighbors(mypattern, 1) %>% cbind()
Neighbors(mypattern, 1) %>% cbind() %>% print()
Neighbors(mypattern, 1) %>% cbind() %>% View()
Neighbors(mypattern, 1) %>% cbindList() %>% View()
Neighbors(mypattern, 1) %>% cbindlist() %>% View()
Neighbors(mypattern, 1) %>% cbind() %>% View()
Neighbors(mypattern, 1)
Neighbors(mypattern, 1) %>% unlist()
Neighbors(mypattern, 1) %>% cbind() %>% fwrite("test_results.txt")
Neighbors(mypattern, 1) %>% cbind() %>% data.frame()
Neighbors(mypattern, 1) %>% cbind() %>% data.frame() %>% distinct()
Neighbors(mypattern, 1)
Neighbors(mypattern, 1) %>% distinct()
Neighbors(mypattern, 1) %>% unique()
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique()
}
return(Neighborhood)
}
mypattern <- "ACG"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
eighbors(mypattern, 1)
Neighbors(mypattern, 1)
Neighbors(mypattern, 1) %>% cbind()
Neighbors(mypattern, 1) %>% cbind() %>% data.frame()
mypattern[-1]
mypattern[1]
SuffixPattern <- mypattern[-1]
Neighbors(SuffixPattern, 1)
SuffixPattern
Neighbors(SuffixPattern, 1)
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique()
}
return(Neighborhood)
}
FirstSymbol <- mypattern[1]
SuffixPattern <- mypattern[-1]
Neighbors(SuffixPattern, 1)
library(data.table)
library(tidyverse)
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(mypattern)) {
symbol <- mypattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
mypattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- mypattern # assign the pattern to the output Neighborhood list
}
}
return(Neighborhood)
}
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique()
}
return(Neighborhood)
}
mypattern <- "ACG"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
mypattern
SuffixPattern <- mypattern[-1]
SuffixPattern
Neighbors(SuffixPattern, 1)
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(pattern)) {
symbol <- pattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
pattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- pattern # assign the pattern to the output Neighborhood list
}
}
return(Neighborhood)
}
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique()
}
return(Neighborhood)
}
mypattern <- "ACG"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
FirstSymbol <- mypattern[1]
SuffixPattern <- mypattern[-1]
Neighbors(SuffixPattern, 1)
HammingDistance <- function(string1, string2) {
# create two vectors from two strings
string1 <- string1 %>% str_split(., "") %>% .[[1]]
string2 <- string2 %>% str_split(., "") %>% .[[1]]
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
HammingDistance
Neighbors(SuffixPattern, 1)
# load packages
library(data.table)
library(tidyverse)
# initiate a Neighborhood list
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(pattern)) {
symbol <- pattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
pattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- pattern # assign the pattern to the output Neighborhood list
}
}
return(Neighborhood)
}
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique()
}
return(Neighborhood)
}
mypattern <- "ACG"
mypattern <- mypattern  %>% str_split(., "") %>% .[[1]]
FirstSymbol <- mypattern[1]
SuffixPattern <- mypattern[-1]
Neighbors(SuffixPattern, 1)
SuffixPattern_Neighbors <- Neighbors(SuffixPattern, 1)
SuffixPattern_Neighbors
length(SuffixPattern_Neighbors)
AppendFirstSymbol <- function() {
for (i in 1:length(SuffixPattern_Neighbors)) {
pattern <- SuffixPattern_Neighbors[i]
if (HammingDistance(pattern, SuffixPattern) < d) {
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=FirstSymbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
new_pattern_list1[[length(diff_nucleotide)*(i-1) + j]] <- c(diff_nucleotide[j], pattern)
}
}
else {
new_pattern_list2[[i]] <- c(FirstSymbol, pattern)
}
}
}
AppendFirstSymbol <- function(SuffixPattern_Neighbors) {
for (i in 1:length(SuffixPattern_Neighbors)) {
pattern <- SuffixPattern_Neighbors[i]
if (HammingDistance(pattern, SuffixPattern) < d) {
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=FirstSymbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
new_pattern_list1[[length(diff_nucleotide)*(i-1) + j]] <- c(diff_nucleotide[j], pattern)
}
}
else {
new_pattern_list2[[i]] <- c(FirstSymbol, pattern)
}
}
}
AppendFirstSymbol(SuffixPattern_Neighbors)
HammingDistance <- function(string1, string2) {
# create two vectors from two strings
string1 <- string1 %>% str_split(., "") %>% .[[1]]
string2 <- string2 %>% str_split(., "") %>% .[[1]]
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
AppendFirstSymbol(SuffixPattern_Neighbors)
d <- 1
AppendFirstSymbol(SuffixPattern_Neighbors)
new_pattern_list1 <- list()
new_pattern_list2 <- list()
AppendFirstSymbol <- function(SuffixPattern_Neighbors) {
for (i in 1:length(SuffixPattern_Neighbors)) {
pattern <- SuffixPattern_Neighbors[i]
if (HammingDistance(pattern, SuffixPattern) < d) {
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=FirstSymbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
new_pattern_list1[[length(diff_nucleotide)*(i-1) + j]] <- c(diff_nucleotide[j], pattern)
}
}
else {
new_pattern_list2[[i]] <- c(FirstSymbol, pattern)
}
}
}
AppendFirstSymbol(SuffixPattern_Neighbors)
AppendFirstSymbol <- function(SuffixPattern_Neighbors) {
for (i in 1:length(SuffixPattern_Neighbors)) {
pattern <- SuffixPattern_Neighbors[i]
if (HammingDistance(pattern, SuffixPattern) < d) {
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=FirstSymbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
new_pattern_list1[[length(diff_nucleotide)*(i-1) + j]] <- c(diff_nucleotide[j], pattern)
}
}
else {
new_pattern_list2[[i]] <- c(FirstSymbol, pattern)
}
}
return(new_pattern_list2)
}
AppendFirstSymbol(SuffixPattern_Neighbors)
