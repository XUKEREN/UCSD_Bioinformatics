sample(c("A", "G", "C", "T"), 4)
sample(c("A", "G", "C", "T"), 100)
sample(c("A", "G", "C", "T"), 100 replace = T)
sample(c("A", "G", "C", "T"), 100, replace = T)
?sample
sample(c("A", "G", "C", "T"), prob = c(0.25, 0.25, 0.25, 0.26), replace = T, 1000)
mylist <- list()
library(data.table)
library(tidyverse)
set.seed(1)
mylist <- list()
for (i in 1:500) {
mylist[[i]] <- sample(c("A", "G", "C", "T"), prob = c(0.25, 0.25, 0.25, 0.26), replace = T, 1000)
}
mylist
myk <- 9
mylist2 <- list()
for (i in 1:500) {
mystr <- mylist[[i]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist2[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
}
}
mylist2
myk <- 9
mylist2 <- list()
for (j in 1:500) {
mystr <- mylist[[j]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist2[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
}
}
mylist2
mystr <- mylist[[1]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist2[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
}
mystr
mylist2
mylist2 %>% flatten()
mylist2 %>% unique()
mylist2 %>% unique() %>% rbindlist()
mylist2 %>% unique() %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
length(mylist)
for (j in 1:length(mylist)) {
mystr <- mylist[[j]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
mylist2[[i]] <- mystr[i:(i + as.numeric(myk) - 1)] %>% unique() %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
}
}
mylist2
myk <- 9
mylist2 <- list()
temp <- list()
for (j in 1:length(mylist)) {
mystr <- mylist[[j]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
temp[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]
mylist2[j] <- temp %>% unique() %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
}
}
for (j in 1:2) {
mystr <- mylist[[j]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
temp[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]  # store all the 9-mer from one 1000-string to a list
mylist2[j] <- temp %>% unique() %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame() # convert the list to data.table and store it to the output list
}
}
mylist2
myk <- 9
mylist2 <- list()
temp <- list()
for (j in 1:2) {
mystr <- mylist[[j]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
temp[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]  # store all the 9-mer from one 1000-string to a list
mylist2[[j]] <- temp %>% unique() %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame() # convert the list to data.table and store it to the output list
}
}
library(data.table)
library(tidyverse)
# randomly generate 500 1000-length vectors with AGCT
set.seed(1)
mylist <- list()
for (i in 1:500) {
mylist[[i]] <- sample(c("A", "G", "C", "T"), prob = c(0.25, 0.25, 0.25, 0.26), replace = T, 1000)
}
mylist
myk <- 9
mylist2 <- list()
temp <- list()
for (j in 1:2) {
mystr <- mylist[[j]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
temp[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]  # store all the 9-mer from one 1000-string to a list
mylist2[[j]] <- temp %>% unique() %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame() # convert the list to data.table and store it to the output list
}
}
mylist2
temp %>% length()
library(data.table)
library(tidyverse)
# randomly generate 500 1000-length vectors with AGCT
set.seed(1)
mylist <- list()
for (i in 1:500) {
mylist[[i]] <- sample(c("A", "G", "C", "T"), prob = c(0.25, 0.25, 0.25, 0.26), replace = T, 1000)
}
mylist
# count the number of 9-mers
mystr <- mylist[[1]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
temp[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]  # store all the 9-mer from one 1000-string to a list
}
temp %>% length()
0.25^9
# a 1000-length vector has 992 9-mer
500*992*0.25^9
# count the number of 9-mers in a 1000-length vector
1:(1 + as.numeric(myk) - 1)]
# count the number of 9-mers in a 1000-length vector
myk = 9
1:(1 + as.numeric(myk) - 1)]
1 + as.numeric(myk) - 1)
1 + as.numeric(myk) - 1
# count the number of 9-mers in a 1000-
1:(i + as.numeric(myk) - 1)
# count the number of 9-mers in a 1000-
1:(1 + as.numeric(myk) - 1)
mystr <- mylist[[1]]
for (i in 1:(length(mystr) - as.numeric(myk) + 1)) {
temp[[i]] <- mystr[i:(i + as.numeric(myk) - 1)]  # store all the 9-mer from one 1000-string to a list
}
temp %>% length()
500*992/(0.25^9)
# we repeat this 500 times
500*992/(4^9)
k <- 3
d <- 1
mystrings <- c("ATTTGGC", "TGCCTTA", "CGGTATC", "GAAAATT")
mystrings
mystrings[[1]]
# split strings to characters
mystring <- mystrings[[1]] %>% str_split(., "") %>% .[[1]]
mystring
# create a place holder list
kmer_list <- vector(mode = "list", length = (length(mystring) - as.numeric(k) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystring) - as.numeric(k) + 1)) {
kmer_list[[i]] <- mystring[i:(i + as.numeric(k) - 1)]
}
kmer_list
# create a place holder list
kmer_list <- vector(mode = "list", length = (length(mystring) - as.numeric(k) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystring) - as.numeric(k) + 1)) {
kmer_list[[i]] <- mystring[i:(i + as.numeric(k) - 1)]
}
# find all the mismatch patterns for the k-mers
###############################################
# initiate a Neighborhood list
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(pattern)) {
symbol <- pattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
pattern_tmp <- pattern
pattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- pattern # assign the pattern to the output Neighborhood list
pattern <- pattern_tmp
}
}
Neighborhood <- c(Neighborhood, list(pattern))
return(Neighborhood)
}
# calculate all mismatch with hamming dist 1. then compute new mismatch with ham dist 1 from prev mismatch and recurse till d.
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
if (length(pattern) == 1) {
Neighborhood # all the output should be in the list format
} else if (length(pattern) > 1) {
if (d == 0) {
Neighborhood = list(pattern) # all the output should be in the list format
} else if (d == 1) {
Neighborhood # all the output should be in the list format
} else if (d > 1) {
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique() # all the output should be in the list format
}
}
}
return(Neighborhood)
}
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
kmer_Neighborhood <- list()
# for (i in 1:length(kmer_list)) {
#   kmer_Neighborhood[[i]] <- AppendFirstSymbol(kmer_list[[i]], d) %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
# }
for (i in 1:length(kmer_list)) {
kmer_Neighborhood[[i]] <- Neighbors(kmer_list[[i]], d) %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
}
kmer_Neighborhood
kmer_Neighborhood_freq_table
kmer_Neighborhood
for (i in 1:length(kmer_list)) {
kmer_Neighborhood[[i]] <- Neighbors(kmer_list[[i]], d) %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
}
kmer_Neighborhood_freq_table <- kmer_Neighborhood %>% unlist() %>% data.frame() %>% table()
kmer_Neighborhood_freq_table
mer_Neighborhood %>% unlist()
kmer_Neighborhood %>% unlist()
kmer_Neighborhood %>% unlist() %>% data.frame()
kmer_Neighborhood %>% unlist() %>% data.frame()
kmer_Neighborhood %>% unlist() %>% data.frame() %>% distinct()
kmer_Neighborhood %>% unlist() %>% data.frame() %>% unique()
kmer_Neighborhood %>% unlist() %>% data.frame() %>% unique()
kmer_Neighborhood %>% unlist() %>% data.frame()
kmer_Neighborhood %>% unlist() %>% data.frame() %>% distinct()
mystring
mystring_1
length(mystrings)
# initiate an output list storing all the k-mers with d mismatch for each string
kmer_Neighborhood_output_list <- list()
k <- 3
d <- 1
mystrings <- c("ATTTGGC", "TGCCTTA", "CGGTATC", "GAAAATT")
# initiate an output list storing all the k-mers with d mismatch for each string
kmer_Neighborhood_output_list <- list()
for (S in 1:length(mystrings)) {
# split strings to characters
mystring <- mystrings[[S]] %>% str_split(., "") %>% .[[1]]
# find all the k-mers
# create a place holder list
kmer_list <- vector(mode = "list", length = (length(mystring) - as.numeric(k) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystring) - as.numeric(k) + 1)) {
kmer_list[[i]] <- mystring[i:(i + as.numeric(k) - 1)]
}
# find all the mismatch patterns for the k-mers
###############################################
# initiate a Neighborhood list
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(pattern)) {
symbol <- pattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
pattern_tmp <- pattern
pattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- pattern # assign the pattern to the output Neighborhood list
pattern <- pattern_tmp
}
}
Neighborhood <- c(Neighborhood, list(pattern))
return(Neighborhood)
}
# calculate all mismatch with hamming dist 1. then compute new mismatch with ham dist 1 from prev mismatch and recurse till d.
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
if (length(pattern) == 1) {
Neighborhood # all the output should be in the list format
} else if (length(pattern) > 1) {
if (d == 0) {
Neighborhood = list(pattern) # all the output should be in the list format
} else if (d == 1) {
Neighborhood # all the output should be in the list format
} else if (d > 1) {
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique() # all the output should be in the list format
}
}
}
return(Neighborhood)
}
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
kmer_Neighborhood <- list()
for (i in 1:length(kmer_list)) {
kmer_Neighborhood[[i]] <- Neighbors(kmer_list[[i]], d) %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
}
kmer_Neighborhood_output_list[[S]] <- kmer_Neighborhood %>% unlist() %>% data.frame() %>% distinct()
}
kmer_Neighborhood_output_list
kmer_Neighborhood %>% unlist()
kmer_Neighborhood %>% unlist() %>% distinct()
kmer_Neighborhood %>% unlist() %>% unique()
# Implement MotifEnumeration
#
# Input: Integers k and d, followed by a space-separated collection of strings Dna.
# Output: All (k, d)-motifs in Dna.
# MotifEnumeration(Dna, k, d)
# Patterns ← an empty set
# for each k-mer Pattern in Dna
# for each k-mer Pattern’ differing from Pattern by at most d mismatches
# if Pattern' appears in each string from Dna with at most d mismatches
#                 add Pattern' to Patterns
# remove duplicates from Patterns
# return Patterns
# Sample Input:
#
#   3 1
# ATTTGGC TGCCTTA CGGTATC GAAAATT
# Sample Output:
#
#   ATA ATT GTT TTT
k <- 3
d <- 1
mystrings <- c("ATTTGGC", "TGCCTTA", "CGGTATC", "GAAAATT")
# initiate an output list storing all the k-mers with d mismatch for each string
kmer_Neighborhood_output_list <- list()
for (S in 1:length(mystrings)) {
# split strings to characters
mystring <- mystrings[[S]] %>% str_split(., "") %>% .[[1]]
# find all the k-mers
# create a place holder list
kmer_list <- vector(mode = "list", length = (length(mystring) - as.numeric(k) + 1))
# put all the K-mer into mylist
for (i in 1:(length(mystring) - as.numeric(k) + 1)) {
kmer_list[[i]] <- mystring[i:(i + as.numeric(k) - 1)]
}
# find all the mismatch patterns for the k-mers
###############################################
# initiate a Neighborhood list
Neighborhood <- list()
# create a ImmediateNeighbor function to generate 1-neigborhood of Pattern
ImmediateNeighbors <- function(pattern) {
for (i in 1:length(pattern)) {
symbol <- pattern[i]
nucleotide <- c("A", "C", "G", "T")
diff_nucleotide <- nucleotide[which(nucleotide!=symbol)] # find all the different nucleotide
for (j in 1:length(diff_nucleotide)) {
pattern_tmp <- pattern
pattern[i] <- diff_nucleotide[j] # find all the different patterns than the original pattern
Neighborhood[[length(diff_nucleotide)*(i-1) + j ]] <- pattern # assign the pattern to the output Neighborhood list
pattern <- pattern_tmp
}
}
Neighborhood <- c(Neighborhood, list(pattern))
return(Neighborhood)
}
# calculate all mismatch with hamming dist 1. then compute new mismatch with ham dist 1 from prev mismatch and recurse till d.
Neighbors <- function(pattern, d) {
Neighborhood <- ImmediateNeighbors(pattern)
if (length(pattern) == 1) {
Neighborhood # all the output should be in the list format
} else if (length(pattern) > 1) {
if (d == 0) {
Neighborhood = list(pattern) # all the output should be in the list format
} else if (d == 1) {
Neighborhood # all the output should be in the list format
} else if (d > 1) {
for (i in 1:(d-1)) {
Neighborhood <- Neighborhood %>% map(ImmediateNeighbors) %>% flatten() %>% unique() # all the output should be in the list format
}
}
}
return(Neighborhood)
}
HammingDistance <- function(string1, string2) {
# compare two vectors
if (is.na((string1==string2) %>% table() %>% .["FALSE"])){
return(0) # if the two vectors are the exact same, then return 0
} else {
return((string1==string2) %>% table() %>% .["FALSE"])
}
}
kmer_Neighborhood <- list()
for (i in 1:length(kmer_list)) {
kmer_Neighborhood[[i]] <- Neighbors(kmer_list[[i]], d) %>% map(paste, collapse="") %>% do.call(rbind, .) %>% as.data.frame()
}
kmer_Neighborhood_output_list[[S]] <- kmer_Neighborhood %>% unlist() %>% unique()
}
kmer_Neighborhood_output_list
Reduce(intersect, kmer_Neighborhood_output_list)
# intersect all the vectors in the list
Reduce(intersect, kmer_Neighborhood_output_list)
# read dataset
fread("dataset_156_8.txt")
